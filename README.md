# Description
This is our final project for the course Data Structures. It is a Git-like repository system built for the purpose of handling data in a filesystem. Users can load datasets and create repositories for them based on the fields with the records being stored in tree-like structures. There is no burden placed on the RAM as the tree and its nodes is a filesystem itself.

# Purpose
The main purpose of this project was to create a system that allows for files to be efficiently managed through the usage of trees while lessening the burden on the RAM caused by such data structures. As such, the trees can be seen as figurative ones, as there are no nodes and pointers managing the data, but files created and stored with paths and other necessary variables (such as height for AVL Trees or color for Red Black Trees) written and updated through I/O operations.

It was very interesting applying the concept of tree data structures to simple files. While many I/O operations can slow down the performance of a program, in this case, the choice of data structure can greatly optimize the task, so it is entirely up to the user to decide which is suitable in what context based on the dataset at hand. 

## Short Explanation of Working
Every insertion, deletion, traversal, or tree function is on the basis of the _key_ of the specific record. The row data is hashed before insertion into the tree to ensure consistency throughout the data, no matter the data type.

This hashing also serves another purpose: consistency with the Merkle Tree. The **Merkle Tree** serves the purpose of verifying data integrity by checking the root of the tree. Every record in the data is hashed and further hashes are generated by hashing two children together, forming a Merkle Tree that grows upwards. When operations occur on the data by modification of the trees, the root hash will be inconsistent with the changed data, alerting that data has been corrupted. 

As for the trees, they mimic the complete functionality of the actual tree data structures, just in the form of a filesystem. When rotations/updates occur, the stored paths and respective unique variables (height for **AVL Trees** and color for **Red Black**) are updated using read and write operations. 

# Functionality
Upon running the program, the user can begin to enter commands to manage versioning and data synchronization. The commands and their functionalities are as follows:
- **init<csv_filepath>**: Initializes the repository for the .csv file containing data and prompts the user to select the field and data stucture (tree type) to store the records. Records are also hashed to ensure integrity, and the user can choose the hash type.
- **branch<branch_name>**: Creates a branch (new folder).
- **commit<commit_message>**: Commits the changes made so far. Updates the Merkle Tree to ensure data integrity. Saves the commit details (message, time, etc.) to the log file.
- **checkout<branch_name>**: Switches to the specified branch.
- **delete-branch<branch_name>**: Deletes the specified branch.
- **current-branch**: Displays the current branch's path.
- **all-branches**: Lists all branches.
- **deletefile<filename>**: Deletes the specified file.

  The trees also have complete insertion and deletion capabilities.

# Contributers
  - <a href=https://github.com/AabiaAli>Aabia Ali</a>
  - <a href=https://github.com/insharahn>Insharah Irfan Nazir</a>
  - <a href=https://github.com/ZaraHEREhehe>Zara Noor Qazi</a>
# License
Licensed under [MIT](https://choosealicense.com/licenses/mit/), this project is open-source and free to use.
